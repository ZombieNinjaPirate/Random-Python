#!/usr/bin/env python


"""
This is an _very_ simplified script that creates a custom formatted log file from the 
firewall.log file thats generated by the iptables rule set on Bifrozt. The new log file
thats generated can be used to visualize the outbound traffic if given to Logstalgia. 
"""


"""
Copyright (c) 2014, Are Hansen - Honeypot Development,

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are
permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list
of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this
list of conditions and the following disclaimer in the documentation and/or other
materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND AN
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""


#   DEV NOTES
#
#   - 20141126: Command line options
#       - input file
#       - output file
#       - maximum number of similar lines/second (default: 650)
#       - blocked traffic tag (defailt: BLOCK)
#       - allowed traffic tag (defailt: ALLOW)
#
#   - 20141126: Replace non-rfc1918 addresses with country names.
#   Use the geoip database to replace any non-rfc1918 address with its country name.
#


__autor__ = 'Are Hansen'
__date__ = '2014, October 10'
__version__ = 'DEV 0.0.2'


import argparse
import sys


def parse_args():
    """Command line options."""
    parser = argparse.ArgumentParser(description='''Make iptables logs compatible with 
                                                    Logstalgia.''')

    files = parser.add_argument_group('- Files')
    files.add_argument('-I', dest='fwlog', help='Firewall log', required=True)
    files.add_argument('-O', dest='outfile', help='Output file', required=True)

    config = parser.add_argument_group('- Configuration options')
    config.add_argument('-N', dest='linesec', help='Number of similar lines per second')

    args = parser.parse_args()
    
    return args


def readLog(fwlog):
    """Read the firewall log, remove any NULL value indexes and return it as a list 
    object. """
    newlog = []
    loglines = []
    
    with open(fwlog, 'r') as lines:
        for line in lines.readlines():
            loglines.append(line.rstrip().split())

    newlog = filter(None, loglines)

    return newlog


def makeNewlog(loglines, outputfile, linesec):
    """Convert the firewall lines into a format thats accepted by Logstalgia. """
    lprsec = []

    for log in loglines:
        # Time stamp format
        date = '[{0}/{1}/2014:{2} +0000]'.format(log[1], log[0], log[2])

        if len(lprsec) == 0:
            lprsec.append(date)

        if len(lprsec) > 0:
            if date in lprsec:
                lprsec.append(date)

            if date not in lprsec:
                lprsec = []
                print '---'
                lprsec.append(date)

        # Check for certain tag words in the list indexes
        for tag in log:

            # Find what action was preformed.
            if 'ALLOW' in tag:
                # If the index contains the ALLOW string, set action = 2
                act = '2'

            if 'BLOCK' in tag:
                # If the index contains the BLOCK string, set action = 1
                act = '1'

            # Find the source and destination.
            if 'SRC=' in tag:
                src = tag.split('=')[1]

            if 'DST=' in tag:
                dst = tag.split('=')[1]

            # Find the protocol thats used.
            if 'PROTO=' in tag:
                prt = tag.split('=')[1]

            # Find the destination port.
            if 'DPT' in tag:
                dpt = tag.split('=')[1]

        if len(lprsec) < int(linesec):
            # Construct the "access.log" like line using the data from the list indexes.
            str1 = '{0} - - {1} "GET {2}{3}'.format(src, date, prt, dpt)
            str2 = '{0}" {1} {0}'.format(act, dst)

            with open(outputfile, 'a') as outfile:
                outfile.write('{0} {1}\n'.format(str1, str2))
                print len(linesec)


def process_args(args):
    """Process the command line options. """
    if not args.linesec:
        args.linesec = 650

    logdata = readLog(args.fwlog)
    makelog = makeNewlog(logdata, args.outfile, args.linesec)


def main():
    """Main function. """
    args = parse_args()
    process_args(args)


if __name__ == '__main__':
    main()


"""
This is the command used by logstalgia when reading the log file:

logstalgia 1280x800 -f -x --glow-duration 0.9 --font-size 14 --hide-paddle \
--disable-progress -g " ,CODE=^2,49,00FF00" -g " ,CODE=^1,49,FF0000" -s 7 -u 1 LOGFILE
"""
